<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Maze Duo FPS - v3</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; z-index: 100; color: #0f0; }
        .menu { border: 2px solid #0f0; padding: 30px; text-align: center; }
        input { background: #111; border: 1px solid #0f0; color: #0f0; padding: 10px; margin: 5px; }
        button { background: #0f0; color: #000; border: none; padding: 15px 30px; cursor: pointer; font-weight: bold; margin-top: 10px; }
        #hud { position: absolute; top: 10px; left: 10px; color: #0f0; z-index: 10; font-size: 18px; pointer-events: none; }
        #instrucoes { position: absolute; bottom: 10px; width: 100%; text-align: center; color: #555; font-size: 12px; }
    </style>
</head>
<body>

<div id="ui">
    <div class="menu">
        <h1>MAZE DUO 3D</h1>
        <input type="text" id="sala" value="777" placeholder="SALA ID"><br>
        <button id="btnJogar">JOGAR AGORA</button>
        <p>Clique no botão e use W,A,S,D para andar</p>
    </div>
</div>

<div id="hud">Nível: 1 | Aguardando...</div>
<div id="instrucoes">Pressione Q para ativar o Mouse ou ESC para soltar</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
let scene, camera, renderer, socket, side, player, partner;
let walls = [], exitBox, canMove = false;
let move = { fwd: false, bck: false, lft: false, rgt: false };
let yaw = 0, currentLevel = 1;

// FUNÇÃO PARA INICIAR TUDO
document.getElementById('btnJogar').onclick = () => {
    conectar();
};

function conectar() {
    const sala = document.getElementById('sala').value;
    socket = new WebSocket('wss://labirint-dou-coop.onrender.com');

    socket.onopen = () => {
        socket.send(JSON.stringify({ type: 'join', token: sala }));
    };

    socket.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        if (data.type === 'start') {
            side = data.side;
            currentLevel = data.level;
            document.getElementById('ui').style.display = 'none';
            canMove = true;
            initScene();
        }
        if (data.type === 'next_level') {
            currentLevel = data.level;
            initScene();
        }
        if (data.type === 'move' && partner) {
            partner.position.set(data.x, 0.5, data.z);
        }
    };
}

// CONTROLES DE MOVIMENTO CORRIGIDOS
window.onkeydown = (e) => {
    let k = e.key.toLowerCase();
    if(k === 'w') move.fwd = true;
    if(k === 's') move.bck = true;
    if(k === 'a') move.lft = true;
    if(k === 'd') move.rgt = true;
    if(k === 'q') document.body.requestPointerLock();
};

window.onkeyup = (e) => {
    let k = e.key.toLowerCase();
    if(k === 'w') move.fwd = false;
    if(k === 's') move.bck = false;
    if(k === 'a') move.lft = false;
    if(k === 'd') move.rgt = false;
};

document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === document.body) {
        yaw -= e.movementX * 0.003;
    }
});

function initScene() {
    // Limpar cena anterior
    if (renderer) {
        renderer.dispose();
        document.body.removeChild(renderer.domElement);
    }
    walls = [];
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 1, 15);
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Gerar Labirinto
    const size = 11 + (currentLevel * 4);
    const grid = generateMazeData(size);
    const geo = new THREE.BoxGeometry(1, 3, 1);
    const mat = new THREE.MeshStandardMaterial({ color: 0x111122 });

    grid.forEach((row, z) => {
        row.forEach((val, x) => {
            if (val === 1) {
                const w = new THREE.Mesh(geo, mat);
                w.position.set(x, 1.5, z);
                scene.add(w);
                walls.push(new THREE.Box3().setFromObject(w));
            } else if (val === 2) {
                const exit = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: 0x00ff00, emissive: 0x00ff00}));
                exit.position.set(x, 1.5, z);
                scene.add(exit);
                exitBox = new THREE.Box3().setFromObject(exit);
            }
        });
    });

    scene.add(new THREE.AmbientLight(0xffffff, 0.1));
    const pLight = new THREE.PointLight(0x00ff00, 2, 8);

    player = new THREE.Group();
    player.position.set(1.5, 1.2, 1.5);
    player.add(pLight);
    scene.add(player);

    partner = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color: 0x00ffff}));
    scene.add(partner);

    document.getElementById('hud').innerText = `Nível: ${currentLevel} | Jogador: ${side}`;
    
    loop();
}

function loop() {
    if (!canMove) return;
    requestAnimationFrame(loop);

    player.rotation.y = yaw;
    let oldPos = player.position.clone();
    
    let vel = new THREE.Vector3();
    if (move.fwd) vel.z -= 0.1;
    if (move.bck) vel.z += 0.1;
    if (move.lft) vel.x -= 0.1;
    if (move.rgt) vel.x += 0.1;

    vel.applyQuaternion(player.quaternion);
    player.position.add(vel);

    // Colisão simplificada
    let pBox = new THREE.Box3().setFromCenterAndSize(player.position, new THREE.Vector3(0.4, 1, 0.4));
    for (let wall of walls) {
        if (pBox.intersectsBox(wall)) {
            player.position.copy(oldPos);
            break;
        }
    }

    // Saída
    if (exitBox && pBox.intersectsBox(exitBox)) {
        socket.send(JSON.stringify({ type: 'reached_exit' }));
        canMove = false; // Trava até o próximo nível
    }

    camera.position.copy(player.position);
    camera.rotation.y = yaw;

    if (socket.readyState === 1) {
        socket.send(JSON.stringify({ type: 'move', side, x: player.position.x, z: player.position.z }));
    }

    renderer.render(scene, camera);
}

function generateMazeData(size) {
    let m = Array(size).fill().map(() => Array(size).fill(1));
    function walk(x, y) {
        m[y][x] = 0;
        let d = [[0,2],[0,-2],[2,0],[-2,0]].sort(() => Math.random()-0.5);
        for(let [dx, dy] of d) {
            let nx=x+dx, ny=y+dy;
            if(nx>0 && nx<size-1 && ny>0 && ny<size-1 && m[ny][nx]===1) {
                m[y+dy/2][x+dx/2]=0; walk(nx, ny);
            }
        }
    }
    walk(1, 1);
    m[size-2][size-2] = 2; // Saída
    return m;
}
</script>
</body>
</html>