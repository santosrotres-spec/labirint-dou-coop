<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Maze Duo - Fix Final</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; color: white; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #0a0a1a; display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .custom-box { background: #161625; padding: 30px; border-radius: 15px; border: 2px solid #4444ff; display: flex; gap: 30px; align-items: center; }
        #char-preview { width: 200px; height: 250px; background: #000; border-radius: 10px; border: 1px solid #444; }
        .controls { display: flex; flex-direction: column; gap: 10px; text-align: center; }
        input { padding: 10px; border-radius: 5px; border: none; width: 220px; align-self: center; }
        input[type="color"] { width: 100px; height: 45px; cursor: pointer; background: none; }
        button { padding: 12px; background: #4444ff; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        button.play { background: #22c55e; font-size: 18px; margin-top: 10px; }
        .label { position: absolute; color: white; background: rgba(0,0,0,0.7); padding: 4px 10px; border-radius: 4px; font-size: 14px; pointer-events: none; transform: translate(-50%, -100%); white-space: nowrap; font-weight: bold; }
        #status-game { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); font-size: 20px; background: rgba(255,0,0,0.5); padding: 15px; border-radius: 8px; display: none; border: 2px solid red; z-index: 10; }
    </style>
</head>
<body>

<div id="ui-overlay">
    <div class="custom-box">
        <div id="char-preview"></div>
        <div class="controls">
            <h1>MAZE DUO</h1>
            <input type="text" id="input-nick" placeholder="Seu Nickname">
            <input type="text" id="input-sala" placeholder="Código da Sala" value="123">
            <span>Cor:</span>
            <input type="color" id="cor-player" value="#ff0000" oninput="updateColor(this.value)">
            <button class="play" onclick="iniciar()">JOGAR</button>
        </div>
    </div>
</div>

<div id="status-game">AGUARDANDO SEGUNDO JOGADOR PARA ABRIR A PORTA...</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
let scene, camera, renderer, socket, side, myNick, playerColor = "#ff0000";
let playerA, playerB, maze = [], wallBoxes = [];
let labelA, labelB, door;
let move = { fwd: false, bck: false, lft: false, rgt: false };
const mazeSize = 31;

// PREVIEW
let previewScene, previewCam, previewRenderer, previewModel;
function initPreview() {
    previewScene = new THREE.Scene();
    previewCam = new THREE.PerspectiveCamera(75, 200/250, 0.1, 10);
    previewCam.position.z = 2;
    previewRenderer = new THREE.WebGLRenderer({ antialias: true });
    previewRenderer.setSize(200, 250);
    document.getElementById('char-preview').appendChild(previewRenderer.domElement);
    previewModel = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), new THREE.MeshStandardMaterial({ color: playerColor }));
    previewScene.add(previewModel, new THREE.AmbientLight(0xffffff, 1));
    function anim() { requestAnimationFrame(anim); previewModel.rotation.y += 0.01; previewRenderer.render(previewScene, previewCam); }
    anim();
}
function updateColor(val) { playerColor = val; previewModel.material.color.set(val); }
initPreview();

function generateMaze(seed) {
    let m = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
    function random(s) { let x = Math.sin(s) * 10000; return x - Math.floor(x); }
    function walk(x, y, s) {
        m[y][x] = 0;
        let dirs = [[0,2],[0,-2],[2,0],[-2,0]].sort(() => random(s++) - 0.5);
        dirs.forEach(([dx, dy]) => {
            let nx = x + dx, ny = y + dy;
            if (nx > 0 && nx < mazeSize && ny > 0 && ny < mazeSize && m[ny][nx] === 1) {
                m[y + dy/2][x + dx/2] = 0; walk(nx, ny, s + 1);
            }
        });
    }
    walk(1, 1, seed);
    for(let i=1; i<4; i++) for(let j=1; j<4; j++) m[i][j] = 0; // Spawn seguro
    return m;
}

function iniciar() {
    // CORREÇÃO DOS INPUTS
    myNick = document.getElementById('input-nick').value || "Player";
    const sala = document.getElementById('input-sala').value || "123";
    
    maze = generateMaze(parseInt(sala));
    labelA = document.createElement('div'); labelA.className = 'label'; document.body.appendChild(labelA);
    labelB = document.createElement('div'); labelB.className = 'label'; document.body.appendChild(labelB);

    socket = new WebSocket('wss://labirint-dou-coop.onrender.com');

    socket.onopen = () => {
        // CORREÇÃO: nick é nick, token é sala!
        socket.send(JSON.stringify({ 
            type: 'join', 
            token: sala, 
            nick: myNick, 
            color: playerColor 
        }));
    };

    socket.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        if (data.type === 'start') {
            side = data.side;
            document.getElementById('ui-overlay').style.display = 'none';
            document.getElementById('status-game').style.display = 'block';
            init3D();
        }
        if (data.type === 'open_door') {
            document.getElementById('status-game').style.display = 'none';
            scene.remove(door);
            wallBoxes = wallBoxes.filter(b => b !== door.BBox);
        }
        if (data.type === 'join' || data.type === 'move') {
            const target = data.side === 'A' ? playerA : playerB;
            if (target) {
                if (data.color) target.material.color.set(data.color);
                if (data.nick) target.nickTag = data.nick;
                if (data.x !== undefined) target.position.set(data.x, 0.5, data.z);
            }
        }
    };
}

function init3D() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a1a);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));

    const wallGeo = new THREE.BoxGeometry(2, 2, 2);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x4444ff });

    maze.forEach((row, z) => {
        row.forEach((val, x) => {
            if (val === 1) {
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.set(x * 2 - mazeSize, 1, z * 2 - mazeSize);
                scene.add(wall);
                const box = new THREE.Box3().setFromObject(wall);
                wallBoxes.push(box);
            }
        });
    });

    // PORTA BLOQUEANDO A SAÍDA
    door = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({ color: 0xff0000 }));
    door.position.set(4 * 2 - mazeSize, 1, 1 * 2 - mazeSize);
    door.BBox = new THREE.Box3().setFromObject(door);
    scene.add(door);
    wallBoxes.push(door.BBox);

    playerA = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
    playerB = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
    playerA.position.set(1 * 2 - mazeSize, 0.5, 1 * 2 - mazeSize);
    playerB.position.set(2 * 2 - mazeSize, 0.5, 2 * 2 - mazeSize);
    scene.add(playerA, playerB);

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    if (!side) return;
    const p = side === 'A' ? playerA : playerB;
    const oldPos = p.position.clone();

    if (move.fwd) p.position.z -= 0.12;
    if (move.bck) p.position.z += 0.12;
    if (move.lft) p.position.x -= 0.12;
    if (move.rgt) p.position.x += 0.12;

    const pBox = new THREE.Box3().setFromCenterAndSize(p.position, new THREE.Vector3(0.7, 0.7, 0.7));
    for (let box of wallBoxes) {
        if (pBox.intersectsBox(box)) { p.position.copy(oldPos); break; }
    }

    camera.position.lerp(new THREE.Vector3(p.position.x, 10, p.position.z + 8), 0.1);
    camera.lookAt(p.position);

    // TAGS DE NOMES
    [ {m: playerA, l: labelA, n: side==='A'?myNick:playerA.nickTag}, 
      {m: playerB, l: labelB, n: side==='B'?myNick:playerB.nickTag} ].forEach(obj => {
        if(!obj.m) return;
        const vec = obj.m.position.clone(); vec.y += 1.2; vec.project(camera);
        obj.l.style.left = `${(vec.x * 0.5 + 0.5) * window.innerWidth}px`;
        obj.l.style.top = `${(-(vec.y * 0.5 - 0.5)) * window.innerHeight}px`;
        obj.l.innerHTML = obj.n || "Carregando...";
    });

    if (socket.readyState === 1) {
        socket.send(JSON.stringify({ type: 'move', side, x: p.position.x, z: p.position.z, nick: myNick, color: playerColor }));
    }
    renderer.render(scene, camera);
}

window.onkeydown = (e) => { const k=e.key.toLowerCase(); if(k=='w')move.fwd=true; if(k=='s')move.bck=true; if(k=='a')move.lft=true; if(k=='d')move.rgt=true; };
window.onkeyup = (e) => { const k=e.key.toLowerCase(); if(k=='w')move.fwd=false; if(k=='s')move.bck=false; if(k=='a')move.lft=false; if(k=='d')move.rgt=false; };
</script>
</body>
</html>