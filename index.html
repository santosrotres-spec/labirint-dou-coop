<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Maze Duo - 10 Levels</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; z-index: 10; color: #0f0; text-align: center; }
        #hud { position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 20px; text-shadow: 2px 2px #000; }
        #msg { position: absolute; top: 50%; width: 100%; text-align: center; color: #fff; font-size: 30px; display: none; }
    </style>
</head>
<body>

<div id="ui">
    <div style="border: 2px solid #0f0; padding: 30px;">
        <h1>MAZE DUO: 10 FASES</h1>
        <input type="text" id="sala" value="777" style="padding:10px;"><br><br>
        <button onclick="conectar()" style="padding:15px; background:#0f0; cursor:pointer;">INICIAR</button>
        <p>Q = Mouse | W,A,S,D = Andar</p>
    </div>
</div>

<div id="hud">NÍVEL: 1</div>
<div id="msg">ESPERANDO PARCEIRO NA SAÍDA...</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
let scene, camera, renderer, socket, side, player, partner, currentLevel = 1;
let walls = [], exitBox, canMove = true;
let move = { fwd: false, bck: false, lft: false, rgt: false };
let yaw = 0;

function conectar() {
    socket = new WebSocket('wss://labirint-dou-coop.onrender.com');
    socket.onopen = () => socket.send(JSON.stringify({ type: 'join', token: document.getElementById('sala').value }));
    
    socket.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        if (data.type === 'start') {
            side = data.side; currentLevel = data.level;
            document.getElementById('ui').style.display = 'none';
            initGame();
        }
        if (data.type === 'waiting_partner') {
            canMove = false;
            document.getElementById('msg').style.display = 'block';
        }
        if (data.type === 'next_level') {
            currentLevel = data.level;
            document.getElementById('msg').style.display = 'none';
            canMove = true;
            if (currentLevel <= 10) initGame();
            else alert("VOCÊS ZERARAM O JOGO!");
        }
        if (data.type === 'move' && partner) {
            partner.position.set(data.x, 0.5, data.z);
        }
    };
}

document.addEventListener('keydown', e => { if(e.key.toLowerCase()==='q') document.body.requestPointerLock(); });
document.addEventListener('mousemove', e => { if(document.pointerLockElement === document.body) yaw -= e.movementX * 0.002; });

function generateMaze(size) {
    let m = Array(size).fill().map(() => Array(size).fill(1));
    function walk(x, y) {
        m[y][x] = 0;
        let d = [[0,2],[0,-2],[2,0],[-2,0]].sort(() => Math.random()-0.5);
        for(let [dx, dy] of d) {
            let nx=x+dx, ny=y+dy;
            if(nx>0 && nx<size-1 && ny>0 && ny<size-1 && m[ny][nx]===1) {
                m[y+dy/2][x+dx/2]=0; walk(nx, ny);
            }
        }
    }
    walk(1, 1);
    m[size-2][size-2] = 2; // Saída
    return m;
}

function initGame() {
    if (renderer) {
        document.body.removeChild(renderer.domElement);
        walls = [];
    }
    
    document.getElementById('hud').innerText = "NÍVEL: " + currentLevel;
    const size = 15 + (currentLevel * 6); // Aumenta o tamanho a cada nível
    const data = generateMaze(size);

    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 1, 15 + currentLevel);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const wallGeo = new THREE.BoxGeometry(1, 3, 1);
    const wallMat = new THREE.MeshStandardMaterial({color: 0x222222});

    data.forEach((row, z) => {
        row.forEach((val, x) => {
            if(val === 1) {
                const w = new THREE.Mesh(wallGeo, wallMat);
                w.position.set(x, 1.5, z); scene.add(w);
                walls.push(new THREE.Box3().setFromObject(w));
            } else if(val === 2) {
                const e = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({color: 0x00ff00, emissive: 0x004400}));
                e.position.set(x, 1.5, z); scene.add(e);
                exitBox = new THREE.Box3().setFromObject(e);
            }
        });
    });

    scene.add(new THREE.AmbientLight(0xffffff, 0.1));
    player = new THREE.Group();
    player.position.set(1.5, 1.2, 1.5);
    player.add(new THREE.PointLight(0x00ff00, 2, 10));
    scene.add(player);

    partner = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshStandardMaterial({color: 0x00ffff, emissive: 0x00ffff}));
    scene.add(partner);

    function animate() {
        requestAnimationFrame(animate);
        if (!canMove) return renderer.render(scene, camera);

        player.rotation.y = yaw;
        const oldPos = player.position.clone();
        const dir = new THREE.Vector3();
        if(move.fwd) dir.z -= 0.12; if(move.bck) dir.z += 0.12;
        if(move.lft) dir.x -= 0.12; if(move.rgt) dir.x += 0.12;
        dir.applyQuaternion(player.quaternion);
        player.position.add(dir);

        const pBox = new THREE.Box3().setFromCenterAndSize(player.position, new THREE.Vector3(0.4, 1, 0.4));
        let hit = false;
        for(let w of walls) if(pBox.intersectsBox(w)) hit = true;
        if(hit) player.position.copy(oldPos);

        if(exitBox && pBox.intersectsBox(exitBox)) {
            socket.send(JSON.stringify({ type: 'reached_exit' }));
        }

        camera.position.copy(player.position);
        camera.rotation.y = yaw;
        if(socket.readyState === 1) socket.send(JSON.stringify({type:'move', side, x: player.position.x, z: player.position.z}));
        renderer.render(scene, camera);
    }
    animate();
}

window.onkeydown = e => { let k=e.key.toLowerCase(); if(k=='w')move.fwd=true; if(k=='s')move.bck=true; if(k=='a')move.lft=true; if(k=='d')move.rgt=true; };
window.onkeyup = e => { let k=e.key.toLowerCase(); if(k=='w')move.fwd=false; if(k=='s')move.bck=false; if(k=='a')move.lft=false; if(k=='d')move.rgt=false; };
</script>
</body>
</html>