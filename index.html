<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Maze FPS Duo</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #ui { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,10,0.9); z-index: 10; color: #0f0; text-align: center; }
        .box { border: 2px solid #0f0; padding: 40px; background: #000; box-shadow: 0 0 20px #0f0; }
        input { background: #000; border: 1px solid #0f0; color: #0f0; padding: 10px; margin: 10px; outline: none; }
        button { background: #0f0; color: #000; border: none; padding: 15px 30px; cursor: pointer; font-weight: bold; }
        #hud { position: absolute; top: 10px; left: 10px; color: #0f0; font-size: 18px; pointer-events: none; }
    </style>
</head>
<body>

<div id="ui">
    <div class="box">
        <h1>MAZE DUO FPS</h1>
        <input type="text" id="nick" placeholder="NICKNAME" maxlength="10"><br>
        <input type="text" id="sala" placeholder="SALA ID" value="777"><br>
        <button onclick="conectar()">INICIAR CONEXÃO</button>
    </div>
</div>
<div id="hud">Aguardando...</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
let scene, camera, renderer, socket, side;
let player, partner, partnerNick = "Amigo";
let walls = [], door, doorBox, finishBox;
let move = { fwd: false, bck: false, lft: false, rgt: false, rotL: false, rotR: false };
let rot = 0;
const mazeSize = 41;

function conectar() {
    const sala = document.getElementById('sala').value;
    socket = new WebSocket('wss://labirint-dou-coop.onrender.com');
    
    socket.onopen = () => {
        socket.send(JSON.stringify({ type: 'join', token: sala, nick: document.getElementById('nick').value }));
    };

    socket.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        if (data.type === 'start') {
            side = data.side;
            document.getElementById('ui').style.display = 'none';
            document.getElementById('hud').innerText = "LADO: " + side + " | ESPERANDO DUPLA...";
            init3D();
        }
        if (data.type === 'open_door') {
            document.getElementById('hud').innerText = "PORTA ABERTA! FUJAM!";
            scene.remove(door); doorBox = null;
        }
        if (data.type === 'move' && data.side !== side) {
            partner.position.set(data.x, 0.5, data.z);
        }
    };
}

function generateMaze() {
    let m = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
    function walk(x, y) {
        m[y][x] = 0;
        let d = [[0,2],[0,-2],[2,0],[-2,0]].sort(() => Math.random()-0.5);
        for(let [dx, dy] of d) {
            let nx=x+dx, ny=y+dy;
            if(nx>0 && nx<mazeSize-1 && ny>0 && ny<mazeSize-1 && m[ny][nx]===1) {
                m[y+dy/2][x+dx/2]=0; walk(nx, ny);
            }
        }
    }
    walk(1, 1);
    // SALA BINÁRIA FIXA
    for(let y=1; y<=3; y++) for(let x=1; x<=3; x++) m[y][x] = 0;
    for(let i=0; i<=4; i++) { m[0][i]=1; m[i][0]=1; m[4][i]=1; m[i][4]=1; }
    m[4][2] = 2; // Porta Vermelha
    m[mazeSize-2][mazeSize-2] = 3; // Saída Dourada
    return m;
}

function init3D() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const data = generateMaze();
    const wallGeo = new THREE.BoxGeometry(1, 2.5, 1);

    data.forEach((row, y) => {
        row.forEach((val, x) => {
            if(val === 1) {
                const w = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({color: 0x111133}));
                w.position.set(x, 1.25, y); scene.add(w);
                walls.push(new THREE.Box3().setFromObject(w));
            } else if(val === 2) {
                door = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({color: 0xff0000, emissive: 0x550000}));
                door.position.set(x, 1.25, y); scene.add(door);
                doorBox = new THREE.Box3().setFromObject(door);
            } else if(val === 3) {
                const f = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({color: 0xffff00, emissive: 0x555500}));
                f.position.set(x, 1.25, y); scene.add(f);
                finishBox = new THREE.Box3().setFromObject(f);
            }
        });
    });

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({color: 0x050505}));
    floor.rotation.x = -Math.PI/2; scene.add(floor);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    let light = new THREE.PointLight(0x00ff00, 1, 10);
    scene.add(light);

    // Player (Câmera) e Partner (Esfera)
    player = new THREE.Group();
    player.position.set(side === 'A' ? 1.5 : 2.5, 1.2, side === 'A' ? 1.5 : 2.5);
    scene.add(player);
    player.add(light); // Luz segue o jogador

    partner = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({color: 0x00ffff}));
    scene.add(partner);

    function animate() {
        requestAnimationFrame(animate);
        
        // Rotação FPS
        if(move.rotL) rot += 0.05;
        if(move.rotR) rot -= 0.05;
        player.rotation.y = rot;

        const oldP = player.position.clone();
        const dir = new THREE.Vector3();
        if(move.fwd) dir.z -= 0.1;
        if(move.bck) dir.z += 0.1;
        if(move.lft) dir.x -= 0.1;
        if(move.rgt) dir.x += 0.1;
        
        dir.applyQuaternion(player.quaternion);
        player.position.add(dir);

        // Colisão
        const pBox = new THREE.Box3().setFromCenterAndSize(player.position, new THREE.Vector3(0.5, 1, 0.5));
        let hit = false;
        for(let w of walls) if(pBox.intersectsBox(w)) hit = true;
        if(doorBox && pBox.intersectsBox(doorBox)) hit = true;
        if(hit) player.position.copy(oldP);

        // Vitória
        if(finishBox && pBox.intersectsBox(finishBox)) location.reload();

        camera.position.copy(player.position);
        camera.rotation.copy(player.rotation);

        if(socket.readyState === 1) {
            socket.send(JSON.stringify({type:'move', side, x: player.position.x, z: player.position.z}));
        }
        renderer.render(scene, camera);
    }
    animate();
}

window.onkeydown = (e) => {
    const k = e.key.toLowerCase();
    if(k=='w') move.fwd=true; if(k=='s') move.bck=true;
    if(k=='a') move.lft=true; if(k=='d') move.rgt=true;
    if(e.keyCode==37) move.rotL=true; if(e.keyCode==39) move.rotR=true;
};
window.onkeyup = (e) => {
    const k = e.key.toLowerCase();
    if(k=='w') move.fwd=false; if(k=='s') move.bck=false;
    if(k=='a') move.lft=false; if(k=='d') move.rgt=false;
    if(e.keyCode==37) move.rotL=false; if(e.keyCode==39) move.rotR=false;
};
</script>
</body>
</html>