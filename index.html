<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Maze Duo - Full Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui-overlay { position: absolute; inset: 0; background: #0a0a1a; display: flex; align-items: center; justify-content: center; z-index: 1000; color: white; }
        .custom-box { background: #161625; padding: 30px; border-radius: 15px; border: 2px solid #4444ff; display: flex; gap: 20px; box-shadow: 0 0 20px rgba(68, 68, 255, 0.3); }
        #char-preview { width: 200px; height: 250px; background: #000; border: 1px solid #444; border-radius: 8px; }
        .controls { display: flex; flex-direction: column; gap: 12px; }
        input { padding: 12px; border-radius: 5px; border: none; background: #2a2a3a; color: white; outline: none; }
        button { padding: 15px; background: #22c55e; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 16px; transition: 0.3s; }
        button:hover { background: #16a34a; }
        .label { position: absolute; color: white; background: rgba(0,0,0,0.8); padding: 4px 10px; border-radius: 4px; font-size: 13px; transform: translate(-50%, -100%); pointer-events: none; border: 1px solid #444; font-weight: bold; }
        #status-msg { position: absolute; top: 20px; width: 100%; text-align: center; color: #ff4444; font-size: 20px; font-weight: bold; display: none; text-shadow: 2px 2px #000; }
    </style>
</head>
<body>

<div id="ui-overlay">
    <div class="custom-box">
        <div id="char-preview"></div>
        <div class="controls">
            <h2 style="margin:0">MAZE DUO</h2>
            <input type="text" id="input-nick" placeholder="Seu Nickname">
            <input type="text" id="input-sala" placeholder="Código da Sala" value="123">
            <label style="font-size: 12px; color: #aaa;">Sua Cor:</label>
            <input type="color" id="input-cor" value="#00ffcc" style="width:100%; height:45px; padding:2px; cursor:pointer">
            <button onclick="iniciar()">JOGAR AGORA</button>
        </div>
    </div>
</div>

<div id="status-msg">AGUARDANDO AMIGO PARA ABRIR A PORTA...</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
let scene, camera, renderer, socket, side, myNick, myColor;
let playerA, playerB, wallBoxes = [], door, doorBox;
let move = { fwd: false, bck: false, lft: false, rgt: false };
const mazeSize = 25;

// PREVIEW DO MENU
let pScene, pCam, pRen, pMesh;
function initPreview() {
    pScene = new THREE.Scene();
    pCam = new THREE.PerspectiveCamera(75, 200/250, 0.1, 10); pCam.position.z = 2;
    pRen = new THREE.WebGLRenderer({ antialias: true }); pRen.setSize(200, 250);
    document.getElementById('char-preview').appendChild(pRen.domElement);
    pMesh = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32, 32), new THREE.MeshStandardMaterial({ color: 0x00ffcc }));
    pScene.add(pMesh, new THREE.AmbientLight(0xffffff, 1), new THREE.DirectionalLight(0xffffff, 0.5));
    document.getElementById('input-cor').oninput = (e) => pMesh.material.color.set(e.target.value);
    function anim() { requestAnimationFrame(anim); pMesh.rotation.y += 0.02; pRen.render(pScene, pCam); }
    anim();
}
initPreview();

// GERAÇÃO BINÁRIA DO LABIRINTO
function generateMazeData(seed) {
    let m = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
    function walk(x, y) {
        m[y][x] = 0;
        let dirs = [[0,2],[0,-2],[2,0],[-2,0]].sort(() => Math.random() - 0.5);
        for(let [dx, dy] of dirs) {
            let nx = x+dx, ny = y+dy;
            if(nx>0 && nx<mazeSize-1 && ny>0 && ny<mazeSize-1 && m[ny][nx] === 1) {
                m[y+dy/2][x+dx/2] = 0; walk(nx, ny);
            }
        }
    }
    walk(1, 1);

    // FORÇAR SALA DE SPAWN (Binário: 0=Chão, 1=Parede, 2=Porta)
    for(let y=1; y<=3; y++) for(let x=1; x<=3; x++) m[y][x] = 0; // Limpa o chão do spawn
    
    // Paredes da sala
    for(let i=0; i<=4; i++) {
        m[0][i] = 1; m[i][0] = 1; // Topo e Esquerda
        m[4][i] = 1; m[i][4] = 1; // Fundo e Direita
    }
    
    // A única saída (Porta)
    m[4][2] = 2; // Posição binária da porta vermelha
    m[5][2] = 0; // Caminho garantido após a porta
    
    return m;
}

function iniciar() {
    myNick = document.getElementById('input-nick').value || "Explorador";
    myColor = document.getElementById('input-cor').value;
    const sala = document.getElementById('input-sala').value;
    
    socket = new WebSocket('wss://labirint-dou-coop.onrender.com');
    socket.onopen = () => {
        socket.send(JSON.stringify({ type: 'join', token: sala, nick: myNick, color: myColor }));
    };

    socket.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        if (data.type === 'start') {
            side = data.side;
            document.getElementById('ui-overlay').style.display = 'none';
            document.getElementById('status-msg').style.display = 'block';
            init3D(generateMazeData(parseInt(sala)));
        }
        if (data.type === 'open_door') {
            document.getElementById('status-msg').style.display = 'none';
            scene.remove(door);
            doorBox = null;
        }
        if (data.type === 'move') {
            const p = data.side === 'A' ? playerA : playerB;
            if(p) { 
                p.position.set(data.x, 0.5, data.z); 
                p.material.color.set(data.color);
                p.nickName = data.nick;
            }
        }
    };
}

function init3D(mazeData) {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));

    // CHÃO SÓLIDO
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(mazeSize*2, mazeSize*2), new THREE.MeshStandardMaterial({ color: 0x111122 }));
    floor.rotation.x = -Math.PI/2;
    floor.position.set(mazeSize/2, 0, mazeSize/2);
    scene.add(floor);

    const wallGeo = new THREE.BoxGeometry(1, 2, 1);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x333366 });

    // CONSTRUÇÃO BASEADA NA MATRIZ BINÁRIA
    mazeData.forEach((row, y) => {
        row.forEach((val, x) => {
            if(val === 1) {
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.set(x, 1, y);
                scene.add(wall);
                wallBoxes.push(new THREE.Box3().setFromObject(wall));
            } else if(val === 2) {
                door = new THREE.Mesh(wallGeo, new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 }));
                door.position.set(x, 1, y);
                scene.add(door);
                doorBox = new THREE.Box3().setFromObject(door);
            }
        });
    });

    playerA = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
    playerB = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff }));
    playerA.position.set(1.5, 0.5, 1.5); playerB.position.set(2.5, 0.5, 2.5);
    scene.add(playerA, playerB);

    const lA = document.createElement('div'); lA.className = 'label'; document.body.appendChild(lA);
    const lB = document.createElement('div'); lB.className = 'label'; document.body.appendChild(lB);

    function animate() {
        requestAnimationFrame(animate);
        const p = side === 'A' ? playerA : playerB;
        if(!p) return;
        const oldPos = p.position.clone();

        if (move.fwd) p.position.z -= 0.1;
        if (move.bck) p.position.z += 0.1;
        if (move.lft) p.position.x -= 0.1;
        if (move.rgt) p.position.x += 0.1;

        // COLISÃO PRECISA
        const pBox = new THREE.Box3().setFromCenterAndSize(p.position, new THREE.Vector3(0.6, 0.6, 0.6));
        let colidiu = false;
        for(let box of wallBoxes) if(pBox.intersectsBox(box)) colidiu = true;
        if(doorBox && pBox.intersectsBox(doorBox)) colidiu = true;
        if(colidiu) p.position.copy(oldPos);

        camera.position.lerp(new THREE.Vector3(p.position.x, 8, p.position.z + 5), 0.1);
        camera.lookAt(p.position);

        [ {m: playerA, l: lA, n: side==='A'?myNick:(playerA.nickName||"Amigo")}, 
          {m: playerB, l: lB, n: side==='B'?myNick:(playerB.nickName||"Amigo")} ].forEach(o => {
            if(!o.m) return;
            const v = o.m.position.clone(); v.y += 0.8; v.project(camera);
            o.l.style.left = `${(v.x * 0.5 + 0.5) * window.innerWidth}px`;
            o.l.style.top = `${(-(v.y * 0.5 - 0.5)) * window.innerHeight}px`;
            o.l.innerHTML = o.n;
        });

        if(socket.readyState === 1) socket.send(JSON.stringify({ type: 'move', side, x: p.position.x, z: p.position.z, color: myColor, nick: myNick }));
        renderer.render(scene, camera);
    }
    animate();
}

window.onkeydown = (e) => { const k=e.key.toLowerCase(); if(k=='w')move.fwd=true; if(k=='s')move.bck=true; if(k=='a')move.lft=true; if(k=='d')move.rgt=true; };
window.onkeyup = (e) => { const k=e.key.toLowerCase(); if(k=='w')move.fwd=false; if(k=='s')move.bck=false; if(k=='a')move.lft=false; if(k=='d')move.rgt=false; };
</script>
</body>
</html>